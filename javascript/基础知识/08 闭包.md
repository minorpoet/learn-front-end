##闭包##

> 函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中成为“闭包”

> 从技术的角度讲，所有的Javascript函数都是闭包： 它们都是对象，都关联到作用域链。

> 当调用函数时闭包所指向的作用域链和定义函数时的作用域链不是同一个作用域链时，事情就变得非常微妙。当一个函数嵌套在另一个函数内，外部函数把嵌套的函数对象作为返回值返回时往往会发生这种事情。这种编程模式在javascript中非常常见。
> 
> 函数定义时的作用域到函数执行时依然有效。 

#####经典代码#####
```
var scope='global scope';
function checkscope(){
	var scope='local scope';
	function f(){ return scope;}
	return f;
}
checkscope()();    // => local scope
``` 
#####经典问题代码#####
```
function constfuncs(){
	var funcs=[];
	for(var i=0; i< 10; i++）{
		funcs[i] = function(){return i;}
	}
	return funcs;
}
var funcs = constfuncs();
funcs[5]();  // =>  10 
```
funcs是在同一个函数调用中定义的，因此它们共享变量i， constfuncs返回的时候变量i的值是10。

其实C#中也有类似的闭包效果，比如函数内部返回一个委托

```
function Func<int> TestClosure(){
    int count=0;
    return new Func<int>(() => count++);
}
var fun= TestClosure();
fun();  // => 0
fun();  // => 1 
```
其实C#的闭包会吧这个int类型的count包装在一个匿名类中而变成引用类型给委托返回值共用；btw 在多线程编程的时候要特别注意闭包问题，因为多线程共享的资源即使是数值类型还最终也是会被clr以匿名类的形式弄成引用类型:

```
for(int i=0; i<5; i++)
{
	int j=i; // 这个接受操作非常重要，如果省略 每个task的i都会是4
	TaskFactory.StartNew(()=>{ 
		// do something with "i" through "j"
	});
}
```








